// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT License.
// See the LICENSE file in the project root for more information. 

<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// This code was generated by a T4 template at <#=DateTime.Now#>.

namespace System.Reactive.Linq
{
    public static partial class Observable
    {
<#
Func<string, string> toUpper = s => char.ToUpper(s[0]) + s.Substring(1);

string[] ordinals = new[] { "first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eighth", "ninth", "tenth", "eleventh", "twelfth", "thirteenth", "fourteenth", "fifteenth", "sixteenth" };

for (int i = 3; i <= 16; i++)
{
    var parameters = string.Join(", ", Enumerable.Range(1, i).Select(j => "IObservable<TSource" + j + "> source" + j));
    var genArgs = string.Join(", ", Enumerable.Range(1, i).Select(j => "TSource" + j));
    var sources = string.Join(", ", Enumerable.Range(1, i).Select(j => "source" + j));
    var paramRefs = string.Join(" or ", Enumerable.Range(1, i).Select(j => "<paramref name=\"source" + j + "\"/>"));

#>
        /// <summary>
        /// Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
        /// </summary>
<#
for (int j = 0; j < i; j++)
{
#>
        /// <typeparam name="TSource<#=j + 1#>">The type of the elements in the <#=ordinals[j]#> source sequence.</typeparam>
<#
}
#>
        /// <typeparam name="TResult">The type of the elements in the result sequence, returned by the selector function.</typeparam>
<#
for (int j = 0; j < i; j++)
{
#>
        /// <param name="source<#=j + 1#>"><#=toUpper(ordinals[j])#> observable source.</param>
<#
}
#>
        /// <param name="resultSelector">Function to invoke whenever any of the sources produces an element.</param>
        /// <returns>An observable sequence containing the result of combining elements of the sources using the specified result selector function.</returns>
        /// <exception cref="ArgumentNullException"><#=paramRefs#> or <paramref name="resultSelector"/> is null.</exception>
        /// <remarks>If a non-empty source completes, its very last value will be used for creating subsequent combinations until all sources terminate.</remarks>
        public static IObservable<TResult> CombineLatest<<#=genArgs#>, TResult>(this <#=parameters#>, Func<<#=genArgs#>, TResult> resultSelector)
        {
<#
for (int j = 0; j < i; j++)
{
#>
            if (source<#=j + 1#> == null)
            {
                throw new ArgumentNullException(nameof(source<#=j + 1#>));
            }

<#
}
#>
            if (resultSelector == null)
            {
                throw new ArgumentNullException(nameof(resultSelector));
            }

            return s_impl.CombineLatest(<#=sources#>, resultSelector);
        }

<#
}
#>
    }

    public static partial class ObservableEx
    {
<#
for (int i = 2; i <= 8; i++)
{
    var parameters = string.Join(", ", Enumerable.Range(1, i).Select(j => "IObservable<T" + toUpper(ordinals[j - 1]) + "> " + ordinals[j - 1]));
    var genArgs = string.Join(", ", Enumerable.Range(1, i).Select(j => "T" + toUpper(ordinals[j - 1])));
    var sources = string.Join(", ", Enumerable.Range(1, i).Select(j => ordinals[j - 1]));
    var paramRefs = string.Join(" or ", Enumerable.Range(1, i).Select(j => "<paramref name=\"" + ordinals[j - 1] + "\"/>"));
    var tuple = "(" + string.Join(", ", Enumerable.Range(1, i).Select(j => "T" + toUpper(ordinals[j - 1]) + " " + toUpper(ordinals[j - 1]))) + ")";
    var vals = string.Join(", ", Enumerable.Range(1, i).Select(j => "t" + j));

#>
        /// <summary>
        /// Merges the specified observable sequences into one observable sequence of tuple values whenever any of the observable sequences produces an element.
        /// </summary>
<#
for (int j = 0; j < i; j++)
{
#>
        /// <typeparam name="T<#=toUpper(ordinals[j])#>">The type of the elements in the <#=ordinals[j]#> source sequence.</typeparam>
<#
}
#>
<#
for (int j = 0; j < i; j++)
{
#>
        /// <param name="<#=ordinals[j]#>"><#=toUpper(ordinals[j])#> observable source.</param>
<#
}
#>
        /// <returns>An observable sequence containing the result of combining elements of the sources using tuple values.</returns>
        /// <exception cref="ArgumentNullException"><#=paramRefs#> is null.</exception>
        public static IObservable<<#=tuple#>> CombineLatest<<#=genArgs#>>(this <#=parameters#>)
        {
<#
for (int j = 0; j < i; j++)
{
#>
            if (<#=ordinals[j]#> == null)
                throw new ArgumentNullException(nameof(<#=ordinals[j]#>));
<#
}
#>

            return s_impl.CombineLatest(<#=sources#>);
        }

<#
}
#>
    }
}
