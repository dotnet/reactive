// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT License.
// See the LICENSE file in the project root for more information. 

<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// This code was generated by a T4 template at <#=DateTime.Now#>.

using System.Linq.Expressions;
using System.Reflection;

namespace System.Reactive.Linq
{
    public static partial class QbservableEx
    {
<#
Func<string, string> toUpper = s => char.ToUpper(s[0]) + s.Substring(1);

string[] ordinals = new[] { "first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eighth", "ninth", "tenth", "eleventh", "twelfth", "thirteenth", "fourteenth", "fifteenth", "sixteenth" };

for (int i = 2; i <= 16; i++)
{
    var parameters = string.Join(", ", Enumerable.Range(1, i).Select(j => "I" + (j == 1 ? "Q" : "O") + "bservable<T" + toUpper(ordinals[j - 1]) + "> " + ordinals[j - 1]));
    var genArgs = string.Join(", ", Enumerable.Range(1, i).Select(j => "T" + toUpper(ordinals[j - 1])));
    var sources = string.Join(", ", Enumerable.Range(1, i).Select(j => ordinals[j - 1]));
    var paramRefs = string.Join(" or ", Enumerable.Range(1, i).Select(j => "<paramref name=\"" + ordinals[j - 1] + "\"/>"));
    var tuple = "(" + string.Join(", ", Enumerable.Range(1, i).Select(j => "T" + toUpper(ordinals[j - 1]) + " " + toUpper(ordinals[j - 1]))) + ")";
    var vals = string.Join(", ", Enumerable.Range(1, i).Select(j => "t" + j));
    var typeofGenArgs = string.Join(", ", Enumerable.Range(1, i).Select(j => "typeof(T" + toUpper(ordinals[j - 1]) + ")"));

#>
        /// <summary>
        /// Merges the specified observable sequences into one observable sequence of tuple values whenever any of the observable sequences produces an element.
        /// </summary>
<#
for (int j = 0; j < i; j++)
{
#>
        /// <typeparam name="T<#=toUpper(ordinals[j])#>">The type of the elements in the <#=ordinals[j]#> source sequence.</typeparam>
<#
}
#>
<#
for (int j = 0; j < i; j++)
{
#>
        /// <param name="<#=ordinals[j]#>"><#=toUpper(ordinals[j])#> observable source.</param>
<#
}
#>
        /// <returns>An observable sequence containing the result of combining elements of the sources using tuple values.</returns>
        /// <exception cref="ArgumentNullException"><#=paramRefs#> is null.</exception>
        public static IQbservable<<#=tuple#>> CombineLatest<<#=genArgs#>>(this <#=parameters#>)
        {
<#
for (int j = 1; j <= i; j++)
{
#>
            if (<#=ordinals[j - 1]#> == null)
                throw new ArgumentNullException(nameof(<#=ordinals[j - 1]#>));
<#
}
#>

            return first.Provider.CreateQuery<<#=tuple#>>(
                Expression.Call(
                    null,
                    ((MethodInfo)MethodInfo.GetCurrentMethod()!).MakeGenericMethod(<#=typeofGenArgs#>),
                    first.Expression,
<#
for (int j = 2; j <= i; j++)
{
#>
                    GetSourceExpression(<#=ordinals[j - 1]#>)<#=j != i ? "," : ""#>
<#
}
#>
                )
            );
        }

<#
}

for (int i = 2; i <= 16; i++)
{
    var parameters = string.Join(", ", Enumerable.Range(1, i).Select(j => "I" + (j == 1 ? "Q" : "O") + "bservable<T" + toUpper(ordinals[j - 1]) + "> " + ordinals[j - 1]));
    var genArgs = string.Join(", ", Enumerable.Range(1, i).Select(j => "T" + toUpper(ordinals[j - 1])));
    var sources = string.Join(", ", Enumerable.Range(1, i).Select(j => ordinals[j - 1]));
    var paramRefs = string.Join(" or ", Enumerable.Range(1, i).Select(j => "<paramref name=\"" + ordinals[j - 1] + "\"/>"));
    var tuple = "(" + string.Join(", ", Enumerable.Range(1, i).Select(j => "T" + toUpper(ordinals[j - 1]) + " " + toUpper(ordinals[j - 1]))) + ")";
    var vals = string.Join(", ", Enumerable.Range(1, i).Select(j => "t" + j));
    var typeofGenArgs = string.Join(", ", Enumerable.Range(1, i).Select(j => "typeof(T" + toUpper(ordinals[j - 1]) + ")"));

#>
        /// <summary>
        /// Merges the specified observable sequences into one observable sequence of tuple values whenever all of the observable sequences have produced an element at a corresponding index.
        /// </summary>
<#
for (int j = 0; j < i; j++)
{
#>
        /// <typeparam name="T<#=toUpper(ordinals[j])#>">The type of the elements in the <#=ordinals[j]#> source sequence.</typeparam>
<#
}
#>
<#
for (int j = 0; j < i; j++)
{
#>
        /// <param name="<#=ordinals[j]#>"><#=toUpper(ordinals[j])#> observable source.</param>
<#
}
#>
        /// <returns>An observable sequence containing the result of combining elements of the sources using tuple values.</returns>
        /// <exception cref="ArgumentNullException"><#=paramRefs#> is null.</exception>
        public static IQbservable<<#=tuple#>> Zip<<#=genArgs#>>(this <#=parameters#>)
        {
<#
for (int j = 1; j <= i; j++)
{
#>
            if (<#=ordinals[j - 1]#> == null)
                throw new ArgumentNullException(nameof(<#=ordinals[j - 1]#>));
<#
}
#>

            return first.Provider.CreateQuery<<#=tuple#>>(
                Expression.Call(
                    null,
                    ((MethodInfo)MethodInfo.GetCurrentMethod()!).MakeGenericMethod(<#=typeofGenArgs#>),
                    first.Expression,
<#
for (int j = 2; j <= i; j++)
{
#>
                    GetSourceExpression(<#=ordinals[j - 1]#>)<#=j != i ? "," : ""#>
<#
}
#>
                )
            );
        }

<#
}
#>
    }
}
