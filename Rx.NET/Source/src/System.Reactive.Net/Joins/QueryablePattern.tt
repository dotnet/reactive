// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT License.
// See the LICENSE file in the project root for more information. 

<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".Generated.cs" #>
using System.Linq.Expressions;
using System.Reactive.Linq;

namespace System.Reactive.Joins
{
    /* The following code is generated by a T4 template. */

    #region Joins auto-generated code (<#=DateTime.Now#>)

<#
Func<string, string> toUpper = s => char.ToUpper(s[0]) + s.Substring(1);

string[] counts = new[] { "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen" };
string[] ordinals = new[] { "first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eighth", "ninth", "tenth", "eleventh", "twelfth", "thirteenth", "fourteenth", "fifteenth", "sixteenth" };

for (int i = 2; i <= 16; i++)
{
    var parameters = string.Join(", ", Enumerable.Range(1, i).Select(j => "IObservable<TSource" + j + "> " + ordinals[j - 1]));
    var genArgs = string.Join(", ", Enumerable.Range(1, i).Select(j => "TSource" + j));
    var sources = string.Join(", ", Enumerable.Range(1, i).Select(j => toUpper(ordinals[j - 1])));

#>
    /// <summary>
    /// Represents a join pattern over <#=counts[i - 1]#> observable sequence<#=i != 1 ? "s" : ""#>.
    /// </summary>
<#
for (int j = 0; j < i; j++)
{
#>
    /// <typeparam name="TSource<#=j + 1#>">The type of the elements in the <#=ordinals[j]#> source sequence.</typeparam>
<#
}
#>
    public class QueryablePattern<<#=genArgs#>> : QueryablePattern
    {
        internal QueryablePattern(Expression expression)
            : base(expression)
        {
        }

<#
if (i > 1 && i != 16)
{
#>
        /// <summary>
        /// Creates a pattern that matches when all <#=counts[i]#> observable sequences have an available element.
        /// </summary>
        /// <typeparam name="TSource<#=i+1#>">The type of the elements in the <#=ordinals[i]#> observable sequence.</typeparam>
        /// <param name="other">Observable sequence to match with the <#=counts[i - 1]#> previous sequences.</param>
        /// <returns>Pattern object that matches when all observable sequences have an available element.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="other"/> is null.</exception>
        public QueryablePattern<<#=genArgs#>, TSource<#=i+1#>> And<TSource<#=i+1#>>(IObservable<TSource<#=i+1#>> other)
        {
            if (other == null)
            {
                throw new ArgumentNullException(nameof(other));
            }

            var t = typeof(QueryablePattern<<#=genArgs#>>);
            var m = t.GetMethod(nameof(And)).MakeGenericMethod(typeof(TSource<#=i + 1#>));
            return new QueryablePattern<<#=genArgs#>, TSource<#=i + 1#>>(
                Expression.Call(
                    Expression,
                    m,
                    Qbservable.GetSourceExpression(other)
                )
            );
        }

<#
}
#>
        /// <summary>
        /// Matches when all observable sequences have an available element and projects the elements by invoking the selector function.
        /// </summary>
        /// <typeparam name="TResult">The type of the elements in the result sequence, returned by the selector function.</typeparam>
        /// <param name="selector">Selector that will be invoked for elements in the source sequences.</param>
        /// <returns>Plan that produces the projected results, to be fed (with other plans) to the When operator.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="selector"/> is null.</exception>
        public QueryablePlan<TResult> Then<TResult>(Expression<Func<<#=genArgs#>, TResult>> selector)
        {
            if (selector == null)
            {
                throw new ArgumentNullException(nameof(selector));
            }

            var t = typeof(QueryablePattern<<#=genArgs#>>);
            var m = t.GetMethod(nameof(Then)).MakeGenericMethod(typeof(TResult));
            return new QueryablePlan<TResult>(
                Expression.Call(
                    Expression,
                    m,
                    selector
                )
            );
        }
    }

<#
}
#>
    #endregion
}
